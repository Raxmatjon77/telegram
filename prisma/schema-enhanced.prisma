// Enhanced Telegram Clone Database Schema
// Addresses security, performance, and feature completeness issues

datasource db {
  url      = env("DATABASE_URL")
  provider = "postgresql"
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

// ============================================================================
// ENUMS
// ============================================================================

enum Role {
  bot
  user
  admin
  moderator
}

enum Language {
  uzb
  rus
  eng
  kaa
  spa
  fra
  deu
  @@map("language")
}

enum UserStatus {
  online
  offline
  away
  busy
  invisible
  @@map("user_status")
}

enum MessageType {
  text
  file
  voice
  video
  image
  document
  sticker
  gif
  poll
  location
  contact
  reply
  forwarded
  system
  @@map("message_type")
}

enum ChatType {
  private
  group
  channel
  supergroup
  @@map("chat_type")
}

enum MessageStatus {
  sending
  sent
  delivered
  read
  failed
  @@map("message_status")
}

enum FileType {
  image
  video
  audio
  document
  voice
  sticker
  @@map("file_type")
}

enum PrivacySettingType {
  last_seen
  profile_photo
  phone_number
  forward_messages
  voice_messages
  @@map("privacy_setting_type")
}

enum PrivacyValue {
  everyone
  contacts
  nobody
  @@map("privacy_value")
}

enum NotificationType {
  message
  mention
  reply
  reaction
  join_chat
  leave_chat
  @@map("notification_type")
}

// ============================================================================
// USER RELATED MODELS
// ============================================================================

model User {
  id        String   @id @default(ulid())
  role      Role     @default(user)
  email     String   @unique
  phone     String?  @unique
  username  String   @unique
  firstName String?  @map("first_name")
  lastName  String?  @map("last_name")
  password  String
  avatar    String?
  bio       String?
  language  Language @default(eng)
  isBot     Boolean  @default(false) @map("is_bot")
  isVerified Boolean @default(false) @map("is_verified")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")
  lastSeenAt DateTime? @map("last_seen_at")

  // Relationships
  messages         Message[]
  chats            ChatParticipant[]
  sessions         Session[]
  ownedChats       Chat[] @relation("OwnerChats")
  blockedUsers     UserBlock[] @relation("BlockerUser")
  blockedByUsers   UserBlock[] @relation("BlockedUser")
  privacySettings  PrivacySetting[]
  userStatuses     UserStatus_Log[]
  sentFriendRequests    FriendRequest[] @relation("SentRequests")
  receivedFriendRequests FriendRequest[] @relation("ReceivedRequests")
  messageReactions MessageReaction[]
  notifications    Notification[]
  files           File[]

  @@index([email])
  @@index([username])
  @@index([phone])
  @@index([isBot])
  @@index([deletedAt])
  @@index([lastSeenAt])
  @@map("users")
}

model Session {
  id        String   @id @default(ulid())
  userId    String   @map("user_id")
  userAgent String?  @map("user_agent")
  ip        String?
  device    String?
  platform  String?
  lastSeen  DateTime @default(now()) @map("last_seen")
  isActive  Boolean  @default(true) @map("is_active")
  socketId  String?  @unique @map("socket_id")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isActive])
  @@index([lastSeen])
  @@map("sessions")
}

model UserStatus_Log {
  id        String     @id @default(ulid())
  userId    String     @map("user_id")
  status    UserStatus
  timestamp DateTime   @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([timestamp])
  @@map("user_status_logs")
}

model UserBlock {
  id        String   @id @default(ulid())
  blockerId String   @map("blocker_id")
  blockedId String   @map("blocked_id")
  reason    String?
  createdAt DateTime @default(now()) @map("created_at")

  blocker User @relation("BlockerUser", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("BlockedUser", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
  @@map("user_blocks")
}

model FriendRequest {
  id         String   @id @default(ulid())
  senderId   String   @map("sender_id")
  receiverId String   @map("receiver_id")
  status     String   @default("pending") // pending, accepted, rejected
  message    String?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  sender   User @relation("SentRequests", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("ReceivedRequests", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([receiverId])
  @@index([status])
  @@map("friend_requests")
}

model PrivacySetting {
  id      String             @id @default(ulid())
  userId  String             @map("user_id")
  type    PrivacySettingType
  value   PrivacyValue
  exceptions String[]         // Array of user IDs for exceptions

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type])
  @@map("privacy_settings")
}

// ============================================================================
// CHAT RELATED MODELS
// ============================================================================

model Chat {
  id          String    @id @default(ulid())
  title       String?
  description String?
  type        ChatType
  ownerId     String?   @map("owner_id")
  avatar      String?
  inviteLink  String?   @unique @map("invite_link")
  isPublic    Boolean   @default(false) @map("is_public")
  membersCount Int      @default(0) @map("members_count")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  deletedAt   DateTime? @map("deleted_at")

  // Relationships
  messages     Message[]
  participants ChatParticipant[]
  owner        User? @relation("OwnerChats", fields: [ownerId], references: [id])

  @@index([title])
  @@index([type])
  @@index([ownerId])
  @@index([isPublic])
  @@index([inviteLink])
  @@index([deletedAt])
  @@map("chats")
}

model ChatParticipant {
  id           String    @id @default(ulid())
  userId       String    @map("user_id")
  chatId       String    @map("chat_id")
  role         String    @default("member") // owner, admin, member
  joinedAt     DateTime  @default(now()) @map("joined_at")
  leftAt       DateTime? @map("left_at")
  isPinned     Boolean   @default(false) @map("is_pinned")
  isMuted      Boolean   @default(false) @map("is_muted")
  isArchived   Boolean   @default(false) @map("is_archived")
  lastReadMessageId String? @map("last_read_message_id")
  unreadCount  Int       @default(0) @map("unread_count")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@unique([userId, chatId])
  @@index([userId])
  @@index([chatId])
  @@index([leftAt])
  @@index([isPinned])
  @@map("chat_participants")
}

// ============================================================================
// MESSAGE RELATED MODELS
// ============================================================================

model Message {
  id              String        @id @default(ulid())
  chatId          String        @map("chat_id")
  senderId        String        @map("sender_id")
  text            String?
  type            MessageType   @default(text)
  replyToId       String?       @map("reply_to_id")
  forwardedFromId String?       @map("forwarded_from_id")
  threadId        String?       @map("thread_id") // For message threads
  editedAt        DateTime?     @map("edited_at")
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")
  deletedAt       DateTime?     @map("deleted_at")

  // Relationships
  chat            Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  sender          User @relation(fields: [senderId], references: [id], onDelete: Cascade)
  replyTo         Message? @relation("MessageReply", fields: [replyToId], references: [id])
  replies         Message[] @relation("MessageReply")
  forwardedFrom   Message? @relation("MessageForward", fields: [forwardedFromId], references: [id])
  forwarded       Message[] @relation("MessageForward")
  thread          Message? @relation("MessageThread", fields: [threadId], references: [id])
  threadMessages  Message[] @relation("MessageThread")
  files           File[]
  reactions       MessageReaction[]
  statuses        MessageStatus_Log[]

  @@index([chatId])
  @@index([senderId])
  @@index([type])
  @@index([createdAt])
  @@index([replyToId])
  @@index([threadId])
  @@index([deletedAt])
  @@index([chatId, createdAt]) // Composite for pagination
  @@map("messages")
}

model MessageReaction {
  id        String   @id @default(ulid())
  messageId String   @map("message_id")
  userId    String   @map("user_id")
  emoji     String   // üëç, ‚ù§Ô∏è, üòÇ, etc.
  createdAt DateTime @default(now()) @map("created_at")

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
  @@map("message_reactions")
}

model MessageStatus_Log {
  id        String        @id @default(ulid())
  messageId String        @map("message_id")
  userId    String        @map("user_id") // Who received/read the message
  status    MessageStatus
  timestamp DateTime      @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([messageId])
  @@index([userId])
  @@index([status])
  @@map("message_status_logs")
}

// ============================================================================
// FILE & MEDIA MODELS
// ============================================================================

model File {
  id        String   @id @default(ulid())
  messageId String?  @map("message_id")
  uploaderId String  @map("uploader_id")
  fileName  String   @map("file_name")
  originalName String @map("original_name")
  mimeType  String   @map("mime_type")
  fileType  FileType @map("file_type")
  size      Int      // in bytes
  url       String
  thumbnailUrl String? @map("thumbnail_url")
  duration  Int?     // for audio/video files (in seconds)
  width     Int?     // for images/videos
  height    Int?     // for images/videos
  createdAt DateTime @default(now()) @map("created_at")

  message  Message? @relation(fields: [messageId], references: [id], onDelete: Cascade)
  uploader User @relation(fields: [uploaderId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([uploaderId])
  @@index([fileType])
  @@index([createdAt])
  @@map("files")
}

// ============================================================================
// NOTIFICATION SYSTEM
// ============================================================================

model Notification {
  id        String           @id @default(ulid())
  userId    String           @map("user_id")
  type      NotificationType
  title     String
  body      String
  data      Json?            // Additional metadata
  isRead    Boolean          @default(false) @map("is_read")
  createdAt DateTime         @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@map("notifications")
}

// ============================================================================
// FULL-TEXT SEARCH (for message search)
// ============================================================================

// Note: This would be implemented as a separate search index in production
// using PostgreSQL's full-text search or Elasticsearch